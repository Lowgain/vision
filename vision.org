#+TITLE: Vision
#+AUTHOR: Nurullah Akkaya
#+STARTUP: hidestars
#+TAGS: NOEXPORT(e)
#+EXPORT_EXCLUDE_TAGS: NOEXPORT
#+LaTeX_CLASS: literate-code

* IplImage to Image
#+srcname: native-lib-iplimage-to-rgb
#+begin_src c :eval never :tangle no
  int* image_size(void* m){
    IplImage* img = (IplImage*)m;    
    int* vals = malloc(2 * sizeof(int));
    vals[0] = img->width;
    vals[1] = img->height;
    return vals;
  }
  
  
  int* pixels(void* m){
    IplImage* img = (IplImage*)m;
      
    int* vals = malloc(img->height * img->width * sizeof(int));
  
    int i,j;
    int index = 0;
    for (i = 0; i < img->height; i++){
      for (j = 0; j < img->width; j++){
  
        uchar* ptr = cvPtr2D(img, i, j, NULL);
  
        unsigned char red = ptr[2];
        unsigned char green = ptr[1];
        unsigned char blue = ptr[0];
  
        vals[index++] = 
          ((255 & 0xFF) << 24) | //alpha
          (((int)red & 0xFF) << 16) | 
          (((int)green & 0xFF) << 8) |
          (((int)blue & 0xFF) << 0);
      }
    }
  
    return vals;
  }
  
#+end_src

#+srcname: clojure-vision-rgb-array-to-bufferedimage
#+begin_src clojure :eval no :tangle no
  (defn image-size [p]
    (let [ref (.invoke (function "image_size") com.sun.jna.ptr.IntByReference (to-array [p]))
          pointer (.getPointer ref)
          info (seq (.getIntArray pointer 0 2))]
      (release-memory ref)
      info))
  
  (defn pixels [p]
    (let [ref (.invoke (function "pixels") com.sun.jna.ptr.IntByReference (to-array [p]))
          pointer (.getPointer ref)
          [width height] (image-size p)
          pxs (.getIntArray pointer 0 (* width height))]
      (release-memory ref)
      pxs))
  
#+end_src

Display video from webcam,

#+begin_src clojure :eval query :tangle no
  (ns display-webcam
    (:use [vision core graphics])
    (:import (javax.swing JFrame)
             (java.awt.event ActionListener KeyListener)))
  
  (defn display []
    (let [capture (capture-from-cam 0)
          state (ref {:loop true :img (image (query-frame capture))})
          frame (proxy [JFrame KeyListener] [] 
                  (paint [g] (.drawImage g (:img @state) 0 0 nil))
                  (keyPressed [e])
                  (keyReleased [e])
                  (keyTyped [e] (dosync (alter state assoc :loop false))))]
      
      (future
       (while (:loop @state)
         (dosync (alter state assoc :img (image (query-frame capture))))
         (.repaint frame))
       (release-capture capture)
       (.setVisible frame false))
      
      (doto frame
        (.addKeyListener frame)
        (.setSize 640 480)
        (.show))))
  
#+end_src

* Isolate HSV Range

Isolate a given HSV range. Matches will be white rest will be black.

#+srcname: native-lib-isolate-hsv
#+begin_src c :eval never :tangle no
  void* isolate_hsv_range(void* image, 
                          int h1, int s1, int v1, 
                          int h2, int s2, int v2){
    // Convert the image into an HSV image
    IplImage* imgHSV = cvCreateImage(cvGetSize((IplImage*)image), 8, 3);
  
    cvCvtColor(image, imgHSV, CV_BGR2HSV);
  
    IplImage* imgThreshed = cvCreateImage(cvGetSize((IplImage*)image), 8, 1);
  
    cvInRangeS(imgHSV, cvScalar(h1, s1, v1, 0), cvScalar(h2, s2, v2, 0), imgThreshed);
  
    cvSmooth( imgThreshed, imgThreshed, CV_GAUSSIAN, 9, 9 , 0 , 0);
  
    cvReleaseImage(&imgHSV);
  
    return (void*)imgThreshed;
  }
  
#+end_src

* Detecting circles

Detect circles in the image that is in the given HSV range.

#+srcname: native-lib-circle
#+begin_src c :eval never :tangle no
  float* circles(void* image, 
                 int h1, int s1, int v1, 
                 int h2, int s2, int v2,
                 int min_r, int max_r, int min_d){
    IplImage* threshed = isolate_hsv_range((IplImage*)image, h1, s1, v1, h2, s2, v2);
  
    CvMemStorage* storage = cvCreateMemStorage(0);
    cvClearMemStorage(storage);
  
    CvSeq* circles = cvHoughCircles(threshed, storage, CV_HOUGH_GRADIENT, 2, 
                                    min_d, 100, 40, min_r, max_r);
    cvReleaseImage(&threshed);
  
    if(circles->total == 0)
      return NULL;
  
    float* coords = malloc((1 + 3 * circles->total) * sizeof(float));
    coords[0] = (float)circles->total;
  
    int i,k;
    for(i=0, k=1; i<circles->total; i++, k+=3){
      float* p = (float*)cvGetSeqElem(circles, i);
      
      coords[k] = p[0];
      coords[k+1] = p[1];
      coords[k+2] = p[2];
  
    }
  
    cvReleaseMemStorage(&storage);
    return coords;
  }
  
#+end_src

Example Clojure code to find yellow circles in an image,

#+begin_src clojure :eval query :tangle no
  (ns find-yellow-circle
    (:use vision.core))
  
  (let [capture (capture-from-cam 0)]
    (future
     (while true
       (let [frame (query-frame capture)
             circles (circles frame
                              [20 100 100]
                              [30 255 255]
                              20 200 100)]
         (println "->" circles)))))
  
#+end_src

Identify Robocup identification numbers,

#+begin_src clojure :eval query :tangle no
  (ns robocup-id
    (:refer-clojure :exclude [+ - * =])
    (:use (clojure.contrib.generic [arithmetic :only [+ - *]]
                                   [comparison :only [=]]))
    (:use [vector-2d.core] :reload-all)
    (:use [vision core graphics util]))
  
  (def image-file "sample/robocup-marker.png")
  
  (defn id-10 [team pink]
    (let [pink (map #(apply vector-2d (take 2 %)) pink)]
      (reduce (fn[h v]
                (let [self (apply vector-2d (take 2 v))
                      [f s] (take 2 (sort-by #(dist self %) pink))]
                  (if (and (in-range? (dist self f) [50 60])
                           (in-range? (dist self s) [50 60])
                           (= -2 (int (bearing self f)))
                           (= 2 (int (bearing self s))))
                    (take 2 v) h))) nil team)))
  
  (defn id-09 [team pink]
    (let [pink (map #(apply vector-2d (take 2 %)) pink)]
      (reduce (fn[h v]
                (let [self (apply vector-2d (take 2 v))
                      [f s] (take 2 (sort-by #(dist self %) pink))]
                  (if (and (in-range? (dist self f) [50 60])
                           (in-range? (dist self s) [50 60])
                           (= -1 (int (bearing self f)))
                           (= 1 (int (bearing self s))))
                    (take 2 v) h))) nil team)))
  
  (let [frame (load-image image-file :color)
        image (image image-file)
        team  (circles frame [115 0 0] [125 255 255] 10 40 45)
        pink (circles frame [145 0 0] [165 255 255] 10 30 35)]
    
    (doseq [c team]
      (circle image c java.awt.Color/red))
    
    (doseq [c pink]
      (circle image c java.awt.Color/yellow))
    
    (plus image (id-10 team pink) java.awt.Color/red)
    (plus image (id-09 team pink) java.awt.Color/red)
    
    (view image))
#+end_src

* Finding bounding boxes
#+srcname: native-lib-bounding-box
#+begin_src c :eval never :tangle no
  int* bounding_boxes(void* image, 
                      int h1, int s1, int v1, 
                      int h2, int s2, int v2){
  
    IplImage* threshed = isolate_hsv_range((IplImage*)image, h1, s1, v1, h2, s2, v2);
  
    CvSeq* boxes;
    CvMemStorage* storage = cvCreateMemStorage(0);
    cvClearMemStorage(storage);
    
    int total = cvFindContours(threshed, storage, &boxes, sizeof(CvContour), 
                               CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
  
    cvReleaseImage(&threshed);
  
    if(total == 0)
      return NULL;
    
    int* coords = malloc((1 + 4 * total) * sizeof(int));
    coords[0] = total;
    
    int k = 1;
    for(; boxes; boxes= boxes->h_next, k+=4){
      CvRect b = cvBoundingRect(boxes, 1);
        
      coords[k] = b.x;
      coords[k+1] = b.y;
      coords[k+2] = b.width;
      coords[k+3] = b.height;
    }

    cvReleaseMemStorage(&storage);
    return coords;
  }
  
#+end_src
* Files                                                            :NOEXPORT:
** Native
*** cmake
#+begin_src text :eval never :tangle native/CMakeLists.txt
  cmake_minimum_required(VERSION 2.8)
  project(vision)
  
  find_package (OpenCV REQUIRED)
  
  add_library(vision SHARED vision.c)
  target_link_libraries(vision cxcore cv highgui)
#+end_src
 
*** vision.c
#+begin_src c :eval never :tangle native/vision.c :noweb yes
  #include <stdio.h>
  #include <stdlib.h>
  #include "cv.h"
  #include "highgui.h"
  
  void* capture_from_cam(int i){
    CvCapture* ptr = cvCaptureFromCAM(i);
     
    /* always check */
    if (!ptr) {
      fprintf( stderr, "Cannot open initialize webcam!\n" );
      return NULL;
    }
    
    return (void*) ptr;
  }
  
  void* query_frame(void* capture){
    return (void*)cvQueryFrame((CvCapture*)capture);
  }
  
  void* load_image(char* file, int color){
    if(color > 0)
      color = CV_LOAD_IMAGE_COLOR;
    else if(color == 0)
      color = CV_LOAD_IMAGE_GRAYSCALE;
    else if(color < 0)
      color = CV_LOAD_IMAGE_UNCHANGED;
  
    (void*)cvLoadImage(file, color);
  }
  
  void save_image(void* image, char* file){
    cvSaveImage( file, (IplImage*)image, NULL);
  }
  
  void release_capture(void* cap){
    CvCapture* capture = (CvCapture*)cap;
    cvReleaseCapture( &capture);
  }
  
  void release_image(void* p){
    IplImage* image = (IplImage*)p;
    cvReleaseImage(&image);
  }
  
  void release_memory(void* p){
    free(p);
  }
  
  <<native-lib-isolate-hsv>>
  <<native-lib-circle>>
  <<native-lib-bounding-box>>
  <<native-lib-iplimage-to-rgb>>
  
#+end_src
** Clojure
*** project.clj
#+begin_src clojure :eval never :tangle project.clj
  (defproject vision "1.0.0-SNAPSHOT"
    :description "FIXME: write"
    :dependencies [[org.clojure/clojure "1.2.0"]
                   [org.clojure/clojure-contrib "1.2.0"]
                   [org.clojars.nakkaya/jna "3.2.7"]
                   [vector-2d "1.0.0-SNAPSHOT"]])
#+end_src

*** core.clj
#+begin_src clojure :tangle src/vision/core.clj :noweb yes
  (ns vision.core
   (:import (com.sun.jna Function Pointer)))
    
  (System/setProperty "jna.library.path" "./native/")
    
  (defn function [f]
   (Function/getFunction "vision" f))
  
  (defn release-memory [p]
    (.invoke (function "release_memory") (to-array [p])))
  
  (defn capture-from-cam [n]
    (.invoke (function "capture_from_cam") Pointer (to-array [n])))
    
  (defn query-frame [c]
    (.invoke (function "query_frame") Pointer (to-array [c])))
  
  (defn release-capture [c]
    (.invoke (function "release_capture") (to-array [c])))
    
  (defn load-image [f c]
    (.invoke (function "load_image") Pointer (to-array [f (cond (= c :color) 1
                                                                (= c :grayscale) 0
                                                                (= c :unchanged) -1)])))
  
  (defn release-image [p]
    (.invoke (function "release_image") (to-array [p])))
  
  (defn save-frame [i f]
    (.invoke (function "save_image") (to-array [i f])))
    
  (defn circles [i [h1 s1 v1] [h2 s2 v2] min-r max-r min-d]
    (if-let[ref (.invoke (function "circles")
                         com.sun.jna.ptr.FloatByReference
                         (to-array [i h1 s1 v1 h2 s2 v2 min-r max-r min-d]))]
      (let [pointer (.getPointer ref)
            count (.getFloat pointer 0)
            circles (partition 3 (seq (drop 1 (.getFloatArray pointer 0 (inc (* 3 count))))))]
        (release-memory ref)
        circles)
      []))
  
  <<clojure-vision-rgb-array-to-bufferedimage>>
  
#+end_src

*** graphics.clj
#+begin_src clojure :tangle src/vision/graphics.clj
  (ns vision.graphics
    (:use [vision core util])
    (:import (com.sun.jna Pointer)))
  
  (defmulti image class)
    
  (defmethod image Pointer [pxs]
             (let [[width height] (image-size pxs)
                   pxs (pixels pxs)]
               (java.awt.image.BufferedImage.
                (. java.awt.image.ColorModel getRGBdefault)
                (java.awt.image.Raster/createPackedRaster
                 (java.awt.image.DataBufferInt. pxs (* width height))
                 width height width  (int-array [0xFF0000 0xFF00 0xFF 0xFF000000]) nil)
                false nil)))
  
  (defmethod image String [f]
             (javax.imageio.ImageIO/read (java.io.File. f)))
  
  (defn- image-panel [image]
    (proxy [javax.swing.JPanel] []
      (paintComponent [g] (.drawImage g image 0 0 this))))
  
  (defn color-picker [f]
    (let [image (image f)
          listener (proxy [java.awt.event.MouseListener] []
                     (mouseClicked
                      [e]
                      (let [x (.getX e) y (.getY e)
                            c (java.awt.Color.
                               (.getRGB image  x y))
                            hsb (java.awt.Color/RGBtoHSB
                                 (.getRed c) (.getGreen c) (.getBlue c) nil)]
                        (println x y (map #(map-int % 0 1 0 179) (seq hsb)))))
                     (mousePressed [e])
                     (mouseReleased [e])
                     (mouseEntered [e])
                     (mouseExited [e]))
          panel  (doto (image-panel image)
                   (.addMouseListener listener))]
      (doto (javax.swing.JFrame.)
        (.add panel)
        (.setAlwaysOnTop true)
        (.setSize (java.awt.Dimension. (.getWidth image) (.getHeight image)))
        (.setVisible true))))
  
  (defn circle [image [x y r] c]
    (let [g (.getGraphics image)]
      (.setColor g c)
      (.draw g (java.awt.geom.Ellipse2D$Double. (- x r) (- y r) (* 2 r) (* 2 r)))))
  
  (defn plus [image [x y] c]
    (let [g (.getGraphics image)]
      (.setColor g c)
      (.drawLine g x y (+ x 50) y)
      (.drawLine g x y (- x 50) y)
      (.drawLine g x y x (+ y 50))
      (.drawLine g x y x (- y 50))))
  
  (defn view [image]
    (doto (javax.swing.JFrame.)
      (.add (image-panel image))
      (.setAlwaysOnTop true)
      (.setSize (java.awt.Dimension. (.getWidth image) (.getHeight image)))
      (.setVisible true)))
  
#+end_src
*** util.clj
#+begin_src clojure :tangle src/vision/util.clj
  (ns vision.util)
  
  (defn map-int [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))
  
  (defn in-range? [x [a b]]
    (if (and (>= x a)
             (<= x b))
      true false))
  
#+end_src
