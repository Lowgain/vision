#+TITLE: Vision
#+AUTHOR: Nurullah Akkaya
#+STARTUP: hidestars
#+TAGS: NOEXPORT(e)
#+EXPORT_EXCLUDE_TAGS: NOEXPORT
#+LaTeX_CLASS: literate-code

This is a literate program, inspired by Donald Knuth. It is intended
to be read like a novel from cover to cover. The ideas are grounded in
the actual source code.  The code in this documment is the executable
source. The appendix gives the procedure for building the library from
the enclosed sources.

* Sample Code
** Capture From a Camera

Connect to a camera and show the images in a Window,

#+begin_src clojure :eval query :tangle no
  (ns display-webcam
    (:use [vision core graphics])
    (:import (javax.swing JFrame)
             (java.awt.event ActionListener KeyListener)))
  
  (defn display []
    (let [capture (capture-from-cam 0)
          state (ref {:loop true :img (query-frame capture)})
          frame (proxy [JFrame KeyListener] [] 
                  (paint [g] (.drawImage g @(second (:img @state)) 0 0 nil))
                  (keyPressed [e])
                  (keyReleased [e])
                  (keyTyped [e] (dosync (alter state assoc :loop false))))]
      
      (future
       (while (:loop @state)
         (dosync (alter state assoc :img (query-frame capture)))
         (.repaint frame))
       (release-capture capture)
       (.setVisible frame false))
      
      (doto frame
        (.addKeyListener frame)
        (.setSize 640 480)
        (.show))))
  
#+end_src
** Tracking Colored Objects
Example Clojure code to find yellow circles in an image,

#+begin_src clojure :eval query :tangle no
  (ns find-yellow-circle
    (:use vision.core))
  
  (let [capture (capture-from-cam 0)]
    (future
     (while true
       (let [frame (query-frame capture)
             circles (circles frame
                              [20 100 100]
                              [30 255 255]
                              20 200 100)]
         (println "->" circles)))))
  
#+end_src

Identify Robocup identification numbers,

#+begin_src clojure :eval query :tangle no
  (ns robocup-id
    (:refer-clojure :exclude [+ - * =])
    (:use (clojure.contrib.generic [arithmetic :only [+ - *]]
                                   [comparison :only [=]]))
    (:use [vector-2d.core] :reload-all)
    (:use [vision core graphics util] :reload-all))
  
  (def image-file "sample/robocup-marker.png")
  
  (defn id-10 [team pink]
    (let [pink (map #(apply vector-2d (take 2 %)) pink)]
      (reduce (fn[h v]
                (let [self (apply vector-2d (take 2 v))
                      [f s] (take 2 (sort-by #(dist self %) pink))]
                  (if (and (in-range? (dist self f) [50 60])
                           (in-range? (dist self s) [50 60])
                           (= -2 (int (bearing self f)))
                           (= 2 (int (bearing self s))))
                    (take 2 v) h))) nil team)))
  
  (defn id-09 [team pink]
    (let [pink (map #(apply vector-2d (take 2 %)) pink)]
      (reduce (fn[h v]
                (let [self (apply vector-2d (take 2 v))
                      [f s] (take 2 (sort-by #(dist self %) pink))]
                  (if (and (in-range? (dist self f) [50 60])
                           (in-range? (dist self s) [50 60])
                           (= -1 (int (bearing self f)))
                           (= 1 (int (bearing self s))))
                    (take 2 v) h))) nil team)))
  
  (let [frame (load-image image-file :color)
        team  (circles frame [115 0 0] [125 255 255] 10 40 45)
        pink (circles frame [145 0 0] [165 255 255] 10 30 35)]
    
    (doseq [c pink]
      (circle frame c java.awt.Color/yellow 3))
    
    (circle frame (concat (id-10 team pink) [20]) java.awt.Color/red -1)
    (circle frame (concat (id-09 team pink) [20]) java.awt.Color/red -1)
    
    (view frame))
  
    
  
#+end_src

** Template Matching
#+begin_src clojure :eval query :tangle no
  (ns template-match
    (:use [vision core graphics]))
  
  (let [raw (load-image "sample/template-input.png" :color)
        template (load-image "sample/template-match.png" :color)
        [min max min-x min-y max-x max-y] (template-match raw template :ccorr-normed)]
    (plus raw [max-x max-y] java.awt.Color/red)
    (view raw))
#+end_src

** Matching Shapes
#+begin_src clojure :eval query :tangle no
  (ns match-shape
    (:use [vision core]))
  
  (let [raw (load-image "sample/shape1.png" :grayscale)
        match (load-image "sample/shape1b_I1.png" :grayscale)
        no-match (load-image "sample/shape1rot_I1.png" :grayscale)]
  
    (println (match-shapes raw match :i1))
    (println (match-shapes raw no-match :i1)))
  
#+end_src
* Core
** IplImage to BufferedImage
#+srcname: native-lib-iplimage-to-rgb
#+begin_src c :eval never :tangle no
  int* image_size(void* m){
    IplImage* img = (IplImage*)m;    
    int* vals = malloc(2 * sizeof(int));
    vals[0] = img->width;
    vals[1] = img->height;
    return vals;
  }
  
  
  int* pixels(void* m){
    IplImage* img = (IplImage*)m;
      
    int* vals = malloc(img->height * img->width * sizeof(int));
  
    int i,j;
    int index = 0;
    for (i = 0; i < img->height; i++){
      for (j = 0; j < img->width; j++){
  
        unsigned char red = CV_IMAGE_ELEM(img, uchar, i-1, (j-1)*3+2);
        unsigned char green = CV_IMAGE_ELEM(img, uchar, i-1, (j-1)*3+1);
        unsigned char blue = CV_IMAGE_ELEM(img, uchar, i-1, (j-1)*3);
  
        vals[index++] = 
          ((255 & 0xFF) << 24) | //alpha
          (((int)red & 0xFF) << 16) | 
          (((int)green & 0xFF) << 8) |
          (((int)blue & 0xFF) << 0);
      }
    }
  
    return vals;
  }
  
#+end_src

#+srcname: clojure-vision-rgb-array-to-bufferedimage
#+begin_src clojure :eval no :tangle no
  (defn image-size [p]
    (let [ref (.invoke (function "image_size") com.sun.jna.ptr.IntByReference (to-array [p]))
          pointer (.getPointer ref)
          info (seq (.getIntArray pointer 0 2))]
      (release-memory ref)
      info))
  
  (defn pixels [p]
    (let [ref (.invoke (function "pixels") com.sun.jna.ptr.IntByReference (to-array [p]))
          pointer (.getPointer ref)
          [width height] (image-size p)
          pxs (.getIntArray pointer 0 (* width height))]
      (release-memory ref)
      pxs))
  
  (defn- buffered-image [pxs]
    (delay
     (let [[width height] (image-size pxs)
           pxs (pixels pxs)]
       (java.awt.image.BufferedImage.
        (. java.awt.image.ColorModel getRGBdefault)
        (java.awt.image.Raster/createPackedRaster
         (java.awt.image.DataBufferInt. pxs (* width height))
         width height width  (int-array [0xFF0000 0xFF00 0xFF 0xFF000000]) nil)
        false nil))))
  
#+end_src
** Isolate HSV Range

Isolate a given HSV range. This function will take an image, and
return a binary image where matches will be white rest will be black.

#+srcname: native-lib-isolate-hsv
#+begin_src c :eval never :tangle no
  void* isolate_hsv_range(void* image, 
                          int h1, int s1, int v1, 
                          int h2, int s2, int v2){
    // Convert the image into an HSV image
    IplImage* imgHSV = cvCreateImage(cvGetSize((IplImage*)image), 8, 3);
  
    cvCvtColor(image, imgHSV, CV_BGR2HSV);
  
    IplImage* imgThreshed = cvCreateImage(cvGetSize((IplImage*)image), 8, 1);
  
    cvInRangeS(imgHSV, cvScalar(h1, s1, v1, 0), cvScalar(h2, s2, v2, 0), imgThreshed);
  
    cvSmooth( imgThreshed, imgThreshed, CV_GAUSSIAN, 9, 9 , 0 , 0);
  
    cvReleaseImage(&imgHSV);
  
    cvSaveImage( "temp3.png", imgThreshed, NULL);
    return (void*)imgThreshed;
  }
  
#+end_src

** Detecting circles

Detect circles in the image that is in the given HSV range.

#+srcname: native-lib-circle
#+begin_src c :eval never :tangle no
  float* circles(void* image, 
                 int h1, int s1, int v1, 
                 int h2, int s2, int v2,
                 int min_r, int max_r, int min_d){
    IplImage* threshed = isolate_hsv_range((IplImage*)image, h1, s1, v1, h2, s2, v2);

    CvMemStorage* storage = cvCreateMemStorage(0);
    cvClearMemStorage(storage);
  
    CvSeq* circles = cvHoughCircles(threshed, storage, CV_HOUGH_GRADIENT, 2, 
                                    min_d, 100, 40, min_r, max_r);
    cvReleaseImage(&threshed);
  
    if(circles->total == 0)
      return NULL;
  
    float* coords = malloc((1 + 3 * circles->total) * sizeof(float));
    coords[0] = (float)circles->total;
  
    int i,k;
    for(i=0, k=1; i<circles->total; i++, k+=3){
      float* p = (float*)cvGetSeqElem(circles, i);
      
      coords[k] = p[0];
      coords[k+1] = p[1];
      coords[k+2] = p[2];
  
    }
  
    cvReleaseMemStorage(&storage);
    return coords;
  }
  
#+end_src

#+srcname: clojure-vision-circles
#+begin_src clojure :eval no :tangle no
  (defn circles [[i _] [h1 s1 v1] [h2 s2 v2] min-r max-r min-d]
    (if-let[ref (.invoke (function "circles")
                         com.sun.jna.ptr.FloatByReference
                         (to-array [i h1 s1 v1 h2 s2 v2 min-r max-r min-d]))]
      (let [pointer (.getPointer ref)
            count (.getFloat pointer 0)
            circles (partition 3 (seq (drop 1 (.getFloatArray pointer 0 (inc (* 3 count))))))]
        (release-memory ref)
        circles)
      []))
#+end_src
** Finding bounding boxes
#+srcname: native-lib-bounding-box
#+begin_src c :eval never :tangle no
  int* bounding_boxes(void* image, 
                      int h1, int s1, int v1, 
                      int h2, int s2, int v2){
  
    IplImage* threshed = isolate_hsv_range((IplImage*)image, h1, s1, v1, h2, s2, v2);
  
    CvSeq* boxes;
    CvMemStorage* storage = cvCreateMemStorage(0);
    cvClearMemStorage(storage);
    
    int total = cvFindContours(threshed, storage, &boxes, sizeof(CvContour), 
                               CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cvPoint(0,0));
  
    cvReleaseImage(&threshed);
  
    if(total == 0)
      return NULL;
    
    int* coords = malloc((1 + 4 * total) * sizeof(int));
    coords[0] = total;
    
    int k = 1;
    for(; boxes; boxes= boxes->h_next, k+=4){
      CvRect b = cvBoundingRect(boxes, 1);
        
      coords[k] = b.x;
      coords[k+1] = b.y;
      coords[k+2] = b.width;
      coords[k+3] = b.height;
    }

    cvReleaseMemStorage(&storage);
    return coords;
  }
  
#+end_src
** Template matching
#+srcname: native-lib-template-matching
#+begin_src c :eval never :tangle no
  int* template_match(void* i, void* t, int mode){
    IplImage* image = (IplImage*)i;
    IplImage* template = (IplImage*)t;
  
    IplImage* result = cvCreateImage(cvSize(image->width - template->width+1, 
                                            image->height - template->height+1), 
                                     IPL_DEPTH_32F, 1);
    cvZero(result);
  
    int calc = -1;
    switch(mode) {
      case 1:
        calc = CV_TM_SQDIFF; break;
      case 2:
        calc = CV_TM_SQDIFF_NORMED; break;
      case 3:
        calc = CV_TM_CCORR; break;
      case 4:
        calc = CV_TM_CCORR_NORMED; break;
      case 5:
        calc = CV_TM_CCOEFF; break;
      case 6:
        calc = CV_TM_CCOEFF_NORMED; break;
    }
  
    cvMatchTemplate(image, template, result, calc);
  
    double min_val=0, max_val=0;
    CvPoint min_loc, max_loc;
    cvMinMaxLoc(result, &min_val, &max_val, &min_loc, &max_loc, NULL);
  
    cvReleaseImage(&result);
  
    int* vals = malloc(6 * sizeof(int));
    vals[0] = min_val;
    vals[1] = max_val;
    vals[2] = min_loc.x;
    vals[3] = min_loc.y;
    vals[4] = max_loc.x;
    vals[5] = max_loc.y;
    return vals;
  }
  
#+end_src

#+srcname: clojure-vision-template-match
#+begin_src clojure :eval no :tangle no
  (defn template-match [[image _] template calculation]
    (let [calculation (cond (= :sqdiff calculation) 1
                            (= :sqdiff-normed calculation) 2
                            (= :ccorr calculation) 3
                            (= :ccorr-normed calculation) 4
                            (= :ccoeff calculation) 5
                            (= :ccoeff-normed calculation) 6)
          ref (.invoke (function "template_match")
                       com.sun.jna.ptr.FloatByReference
                       (to-array [image template calculation]))
          pointer (.getPointer ref)
          vals (.getIntArray pointer 0 6)]
      (release-memory ref)
      vals))
#+end_src

** Matching Shapes
#+srcname: native-lib-matching-shapes
#+begin_src c :eval never :tangle no
  double match_shape(void* i1, void* i2, int mode){
    IplImage* img1 = (IplImage*)i1;
    IplImage* img2 = (IplImage*)i2;
  
    int calc = -1;
    switch(mode) {
      case 1:
        calc = CV_CONTOURS_MATCH_I1; break;
      case 2:
        calc = CV_CONTOURS_MATCH_I2; break;
      case 3:
        calc = CV_CONTOURS_MATCH_I3; break;
    }
  
    return cvMatchShapes (img1, img2, calc, 0);
  }
  
#+end_src

#+srcname: clojure-vision-match-shape
#+begin_src clojure :eval no :tangle no
  (defn match-shapes [img1 img2 calculation]
    (let [calculation (cond (= :i1 calculation) 1
                            (= :i2 calculation) 2
                            (= :i3 calculation) 3)]
      (.invoke (function "match_shape") Double (to-array [img1 img2 calculation]))))
  
#+end_src

** Misc
#+srcname: native-lib-capture-camera
#+begin_src c :eval never :tangle no
  void* capture_from_cam(int i){
    CvCapture* ptr = cvCaptureFromCAM(i);
     
    /* always check */
    if (!ptr) {
      fprintf( stderr, "Cannot open initialize webcam!\n" );
      return NULL;
    }
    
    return (void*) ptr;
  }
  
  void* query_frame(void* capture){
    return (void*)cvQueryFrame((CvCapture*)capture);
  }  

  void release_capture(void* cap){
    CvCapture* capture = (CvCapture*)cap;
    cvReleaseCapture( &capture);
  }
#+end_src

#+srcname: clojure-vision-capture-camera
#+begin_src clojure :eval never :tangle no
  (defn capture-from-cam [n]
    (.invoke (function "capture_from_cam") Pointer (to-array [n])))
    
  (defn query-frame [c]
    (let [ref (.invoke (function "query_frame") Pointer (to-array [c]))]
      [ref (buffered-image ref)]))
  
  (defn release-capture [c]
    (.invoke (function "release_capture") (to-array [c])))
  
#+end_src

#+srcname: native-lib-image
#+begin_src c :eval never :tangle no
  void* load_image(char* file, int color){
    if(color > 0)
      color = CV_LOAD_IMAGE_COLOR;
    else if(color == 0)
      color = CV_LOAD_IMAGE_GRAYSCALE;
    else if(color < 0)
      color = CV_LOAD_IMAGE_UNCHANGED;
  
    (void*)cvLoadImage(file, color);
  }
  
  void save_image(void* image, char* file){
    cvSaveImage( file, (IplImage*)image, NULL);
  }
  
  void release_image(void* p){
    IplImage* image = (IplImage*)p;
    cvReleaseImage(&image);
  }
#+end_src

#+srcname: clojure-vision-image
#+begin_src clojure :eval never :tangle no
  (defn load-image [f c]
    (let [ref (.invoke (function "load_image") Pointer (to-array [f (cond (= c :color) 1
                                                                          (= c :grayscale) 0
                                                                          (= c :unchanged) -1)]))]
      [ref (buffered-image ref)]))
  
  (defn release-image [[p _]]
    (.invoke (function "release_image") (to-array [p])))
  
  (defn save-image [[p _] f]
    (.invoke (function "save_image") (to-array [p f])))
  
#+end_src

#+srcname: native-lib-convert-color
#+begin_src c :eval never :tangle no
  void* convert_color(void* i, int mode){
    IplImage* image = (IplImage*)i;
    IplImage* converted = cvCreateImage(cvGetSize((IplImage*)image), image->depth, image->nChannels);
    
    if(mode == 1)
      mode = CV_RGB2HSV;
    else if (mode == 2)
      mode = CV_HSV2RGB;
    else if (mode == 3)
      mode = CV_BGR2HSV;
    else if (mode == 4)
      mode = CV_HSV2BGR;
  
    cvCvtColor(image, converted, mode);  
  
    return (void*)converted;
  }
#+end_src

#+srcname: clojure-vision-convert-color
#+begin_src clojure :eval never :tangle no
  (defn convert-color [[p _] m]
    (let [ref (.invoke (function "convert_color") Pointer
                       (to-array [p (cond (= m :rgb-hsv) 1
                                          (= m :hsv-rgb) 2
                                          (= m :bgr-hsv) 3
                                          (= m :hsv-bgr) 4
                                          :default (throw (Exception. "Unknown Convertion.")))]))]
      [ref (buffered-image ref)]))
#+end_src

#+srcname: native-lib-in-range-s
#+begin_src c :eval never :tangle no
  void* in_range_s(void* i, int s11, int s12, int s13, int s14, int s21, int s22, int s23, int s24){
    IplImage* image = (IplImage*)i;
    IplImage* processed = cvCreateImage(cvGetSize((IplImage*)image), 8, 1);
    cvInRangeS(image, cvScalar(s11, s12, s13, s14), cvScalar(s21, s22, s23, s24), processed);
    return (void*)processed;
  }
#+end_src

#+srcname: clojure-in-range-s
#+begin_src clojure :eval never :tangle no
  (defn in-range-s [[p _] [s11 s12 s13 s14] [s21 s22 s23 s24]]
    (let [ref (.invoke (function "in_range_s") Pointer (to-array [p s11 s12 s13 s14 s21 s22 s23 s24]))]
      [ref (buffered-image ref)]))
#+end_src

#+srcname: native-lib-smooth
#+begin_src c :eval never :tangle no
  void* smooth(void* i, int mode, int param1, int param2, int param3, int param4){
    IplImage* image = (IplImage*)i;
    IplImage* ret = cvCreateImage(cvGetSize((IplImage*)image), image->depth, image->nChannels);

    if(mode == 1)
      mode = CV_BLUR_NO_SCALE;
    else if (mode == 2)
      mode = CV_BLUR;
    else if (mode == 3)
      mode = CV_GAUSSIAN;
    else if (mode == 4)
      mode = CV_MEDIAN;
    else if (mode == 5)
      mode = CV_BILATERAL;

    cvSmooth(image, ret, mode, param1, param2 , param3 , param4);

    return (void*)ret;
  }
#+end_src

#+srcname: clojure-vision-smooth
#+begin_src clojure :eval never :tangle no
  (defn smooth [[p _] m p1 p2 p3 p4]
    (let [ref (.invoke (function "smooth") Pointer
                       (to-array [p (cond (= m :blur-no-scale) 1
                                          (= m :blur) 2
                                          (= m :gaussian) 3
                                          (= m :median) 4
                                          (= m :bilateral) 5
                                          :default (throw (Exception. "Unknown Convertion.")))
                                  p1 p2 p3 p4]))]
      [ref (buffered-image ref)]))
  
#+end_src

#+srcname: native-lib-free
#+begin_src c :eval never :tangle no
  void release_memory(void* p){
    free(p);
  }
#+end_src

#+srcname: clojure-vision-free
#+begin_src clojure :eval never :tangle no
  (defn release-memory [p]
    (.invoke (function "release_memory") (to-array [p])))
#+end_src

* Graphics
Routines for manipulating images,

#+srcname: clojure-graphics-color-picker
#+begin_src clojure :eval no :tangle no
  (defn- image-panel [image]
    (proxy [javax.swing.JPanel] []
      (paintComponent [g] (.drawImage g image 0 0 this))))
  
  (defn color-picker [[pointer image]]
    (let [listener (proxy [java.awt.event.MouseListener] []
                     (mouseClicked
                      [e]
                      (let [x (.getX e) y (.getY e)
                            c (java.awt.Color.
                               (.getRGB @image  x y))
                            hsb (java.awt.Color/RGBtoHSB
                                 (.getRed c) (.getGreen c) (.getBlue c) nil)]
                        (println x y (map #(map-int % 0 1 0 179) (seq hsb)))))
                     (mousePressed [e])
                     (mouseReleased [e])
                     (mouseEntered [e])
                     (mouseExited [e]))
          panel  (doto (image-panel @image)
                   (.addMouseListener listener))]
      (doto (javax.swing.JFrame.)
        (.add panel)
        (.setAlwaysOnTop true)
        (.setSize (java.awt.Dimension. (.getWidth @image) (.getHeight @image)))
        (.setVisible true))))
#+end_src

Displays the image in a frame with a mouse listener attached that will
print the HSV values for the pixels clicked.

#+srcname: clojure-graphics-circle
#+begin_src clojure :eval no :tangle no
  (defn circle [[pointer image] [x y r] color thickness]
    (let [g (.getGraphics @image)]
      (.setColor g color)
    (if (pos? thickness)
      (doto g
        (.setStroke (java.awt.BasicStroke. thickness))
        (.draw (java.awt.geom.Ellipse2D$Double. (- x r) (- y r) (* 2 r) (* 2 r))))
      (.fill g (java.awt.geom.Ellipse2D$Double. (- x r) (- y r) (* 2 r) (* 2 r))))))
  
#+end_src

Draws simple, thick or filled circle,

#+srcname: clojure-graphics-line
#+begin_src clojure :eval no :tangle no
  (defn line [[pointer image] [x1 y1] [x2 y2] color thickness]
    (doto (.getGraphics @image)
      (.setColor color)
      (.setStroke (java.awt.BasicStroke. thickness))
      (.drawLine x1 y1 x2 y2)))
  
#+end_src

Draws simple or thick line segment,

#+srcname: clojure-graphics-view
#+begin_src clojure :eval no :tangle no
  (defn view [[pointer image]]
    (doto (javax.swing.JFrame.)
      (.add (image-panel @image))
      (.setAlwaysOnTop true)
      (.setSize (java.awt.Dimension. (.getWidth @image) (.getHeight @image)))
      (.setVisible true)))
#+end_src

Displays the image in a frame,

* Files                                                            :NOEXPORT:
** Native
*** cmake
#+begin_src text :eval never :tangle native/CMakeLists.txt
  cmake_minimum_required(VERSION 2.8)
  project(vision)
  
  find_package (OpenCV REQUIRED)
  
  add_library(vision SHARED vision.c)
  target_link_libraries(vision cxcore cv highgui)
#+end_src
 
*** vision.c
#+begin_src c :eval never :tangle native/vision.c :noweb yes
  #include <stdio.h>
  #include <stdlib.h>
  #include "cv.h"
  #include "highgui.h"
  
  <<native-lib-capture-camera>>
  <<native-lib-image>>
  <<native-lib-free>>
  <<native-lib-isolate-hsv>>
  <<native-lib-circle>>
  <<native-lib-bounding-box>>
  <<native-lib-iplimage-to-rgb>>
  <<native-lib-template-matching>>
  <<native-lib-matching-shapes>>
  <<native-lib-convert-color>>
  <<native-lib-in-range-s>>
  <<native-lib-smooth>>
#+end_src
** Clojure
*** project.clj
#+begin_src clojure :eval never :tangle project.clj
  (defproject vision "1.0.0-SNAPSHOT"
    :description "FIXME: write"
    :dependencies [[org.clojure/clojure "1.2.0"]
                   [org.clojure/clojure-contrib "1.2.0"]
                   [org.clojars.nakkaya/jna "3.2.7"]
                   [vector-2d "1.0.0-SNAPSHOT"]])
#+end_src

*** core.clj
#+begin_src clojure :tangle src/vision/core.clj :noweb yes
  (ns vision.core
   (:import (com.sun.jna Function Pointer)))
    
  (System/setProperty "jna.library.path" "./native/")
    
  (defn function [f]
   (Function/getFunction "vision" f))

  <<clojure-vision-free>>
  <<clojure-vision-rgb-array-to-bufferedimage>>
  <<clojure-vision-image>>
  <<clojure-vision-capture-camera>>
  <<clojure-vision-circles>>
  <<clojure-vision-template-match>>
  <<clojure-vision-match-shape>>
  <<clojure-in-range-s>>
  <<clojure-vision-convert-color>>
  <<clojure-vision-smooth>>
#+end_src

*** graphics.clj
#+begin_src clojure :tangle src/vision/graphics.clj :noweb yes
  (ns vision.graphics
    (:use [vision core util]))
  
  <<clojure-graphics-color-picker>>
  <<clojure-graphics-circle>>
  <<clojure-graphics-line>>
  <<clojure-graphics-view>>  
#+end_src
*** util.clj
#+begin_src clojure :tangle src/vision/util.clj
  (ns vision.util)
  
  (defn map-int [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))
  
  (defn in-range? [x [a b]]
    (if (and (>= x a)
             (<= x b))
      true false))
  
#+end_src
